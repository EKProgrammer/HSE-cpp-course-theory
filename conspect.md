# Конспект по курсу С++
### Корчагин Егор
	
# Лекция 2 - Control flow
	
Тип переменной определён на старте.
``` cpp
int a;
a = 0;
```

Нельзя дальше делать так:
``` cpp	
a = "asd";
```

**int** - это знаковое число, можно считать, что оно 32-битное (4 байтное),
т. е. в него влезают числа от -2 147 483 648 до 2 147 483 647.
	
**char** - символ, 1 байтный тип данных: от -128 до 127 по умолчанию.
``` cpp
char ch = 'f';
```
	
Символами являются ASCII-символы, буква *'ф'* не является символом в C++.

![Alt text](/img/ASCII.png "a title")
	
(Таблица ASCII с шестнадцатеричными кодами символов. Слева указана старшая
шестнадцатеричная цифра, сверху — младшая. Цветом выделены так называемые
управляющие символы, обычно не имеющие графического представления.)
	
## Условный оператор
``` cpp
if (a > 0) {
	std::cout << a << " is positive" << std::endl;
} else if (a < 0) {
	std::cout << a << " is negative" << std::endl;
} else {
	std::cout << a << " a zero" << std::endl;
}
```
	
Style-guide: всегда пишем фигурные скобки.
	
## Циклы
	
``` cpp
for (int i = 0; i < 10; ++i) {
	std::cout << i << std::endl;
}
```
	
**for**, который никогда не завершается	
``` cpp
for (;;) {
	std::cout << 1 << std::endl;
}
```
	
Ещё пример
``` cpp
for (int a = 5, b = 4, c = 3; a * a = b * b + c * c; ++a, ++b, ++ c) {
	std::cout << a << ' ' << b << ' ' << c << std::endl;
}
```
	
Лучше всегда инициализировать переменные, чтобы избежать **underfined
behaviour**
``` cpp
int a = 0;
```
	
Пока выполняется условие в скобках, исполняется тело цикла
``` cpp
while (true) {
	
}
```
	
Cначала выполняем первую итерацию цикла, затем проверяем условие
``` cpp
do {
	
} while (true);
```
    
## Оператор **switch**
``` cpp
int a;
std::cin >> a;

// a - всегда число в switch
switch (a) {
case 0:
    std::cout << "zero" << std::endl;
case 1:
    std::cout << "one" << std::endl;
case 2:
    std::cout << "two" << std::endl;
default:
    std::cout << "a lot" << std::endl;
}

// Ввод: a = 0
// Вывод:
// zero
// one
// two
// a lot

// Ввод: a = 2
// Вывод:
// two
// a lot
```
	
**default** выполняется, если ни одна ветка не подошла. Если **default** нет, то
ничего не выполнится.
	
Если добавить **break**:
	
``` cpp
int a;
std::cin >> a;

switch (a) {
case 0:
    std::cout << "zero" << std::endl;
    break;
case 1:
    std::cout << "one" << std::endl;
    break;
case 2:
    std::cout << "two" << std::endl;
    break;
default:
   std::cout << "a lot" << std::endl;
   break;
}

// Input: a = 0
// Output: zero
// Input: a = 3
// Output: a lot
```
	
В **switch** нельзя создавать переменные. Но добавив фигурные скобки, можно.
	
``` cpp	
int a;
std::cin >> a;
	
switch (a) {
	case 0: {
		int x = 5;
		std::cout << "zero" << std::endl;
		break;
	}
	case 1:
		std::cout << "one" << std::endl;
		break;
	case 2:
		std::cout << "two" << std::endl;
		break;
}
```
	
В таком случае на 4, 6, 8 программа скажет, что они чётные.
	
``` cpp
int a = 0;
switch (a) {
    case 4:
    case 6:
    case 8:
        std::cout << "even" << std::endl;
        break;
}
```
	
## Арифметические операции
	
Битовый сдвиг влево (умножение на $2^{10}$)
	
``` cpp
std::cout << (a << 10) << std::endl;
```
	
Битовый сдвиг влево (деление на $2^{10}$)

``` cpp
std::cout << (a >> 10) << std::endl;
```
	
Побитовое И. Действует эквивалентно логическому И, но примененному к каждой паре
битов двоичного числа.
``` cpp
std::cout << (a & b) << std::endl;
```
	
Побитовое ИЛИ. Действует эквивалентно логическому ИЛИ, но примененному к каждой
паре битов двоичного числа.
``` cpp
std::cout << (a | b) << std::endl;
```
	
XOR. Устанавливает значение бита результата в 1, если значения в соответствующих
битах исходных переменных различны. 
``` cpp
std::cout << (a ^ b) << std::endl;
```
	
Побитовое отрицание. Инвертирует состояние каждого бита исходной переменной. 
``` cpp
std::cout << ~a << std::endl;
```

# Лекция 3: Фундаментальные типы

В статической типизации, которая характерна для C++, типы данных проверяются
во время компиляции. Тип каждой переменной и функции нужно объявить заранее,
а компилятор проверит, соответствуют ли они типам данных, которые используются
в программе.

С++ имеет слабую типизацию, есть автоматическое приведение типов:

``` cpp
auto x = 'a' - 1;
PrintType(x) -> "int"
```

**auto** автоматически присваивает тип переменной, но этот тип всё ещё не может
быть в дальнейшем изменён.

``` cpp
auto x = 0; // int
```

## Фундаментальные типы

- Встроенные в язык типы
- Целочисленные, с плавающей точкой

## Void

Множество возможных значений иногда пустое, иногда содержит одно значение
(**unit type**).

``` cpp
void foo() {
    return;
}
```

## Целочисленные типы. Char
- Один байт (!!!).
- совместительству - один символ в базовой кодировке.
- совместительству - число.
- Ширина в битах:
	- CHAR_BIT
	- std::numeric_limits<char>::digits 
- Ширина в байтах:
	``` cpp
	char x = 'a';
	static_assert(size_of(x) == 1);
	```

## Целочисленные типы. Int

Ширина в битах не зафиксирована точно

Модификаторы **signed int** и **unsigned int**, знаковый и беззнаковый тип
соотвественно.
 
Всё это одно и тоже: **signed int == int == signed, unsigned int == unsigned**.

Плюсовый байт - кусочек памяти, из которого состоят все объекты. Он достаточно
близок к компьютерному байту. Поэтому в С++ все объекты имеют размер **кратный
количеству бит в одном байте**. Если байт имеет размер 8 бит, то размеры всех
типов будут кратны 8 битам. Стандарт гарантирует, что байт **как минимум 8 бит**.


|        Тип         |                     Размер                      | Диапазон значений (x86-64) |
|:------------------:|:-----------------------------------------------:|:--------------------------:|
|        char        |         всегда 1 байт (в x86-64 8 бит)          |       От -128 до 127       |
|   unsigned char    |             1 байт (в x86-64 8 бит)             |        От 0 до 255         |
|        bool        |                     1 байт                      |       false или true       |
|     short int      |           >= 16 бит (в x86-64 16 бит)           |  От `-2^15` до `2^15 - 1`  |
|   unsigned short   |           >= 16 бит (в x86-64 16 бит)           |     От 0 до `2^16 - 1`     |
|        int         |          >= 16 бит (в x86-64 32 бита)           |  От `-2^31` до `2^31 - 1`  |
|    unsigned int    |          >= 16 бит (в x86-64 32 бита)           |     От 0 до `2^32 - 1`     |
|        long        | 32/64 бита (в Windows 32 бита, в Linux 64 бита) |  От `-2^31` до `2^31 - 1`  |
|   unsigned long    | 32/64 бита (в Windows 32 бита, в Linux 64 бита) |     От 0 до `2^32 - 1`     |
|     long long      |          >= 64 бита (в x86-64 64 бита)          |  От `-2^63` до `2^63 - 1`  |
| unsigned long long |          >= 64 бита (в x86-64 64 бита)          |     От 0 до `2^64 - 1`     |

Переполнение беззнаковых типов данных определено: после переполнения значение
обнуляется. Это поведение не **underfined behavior**, оно зафиксировано в
стандарте.

``` cpp
unsigned int y = ~0;

std::cout << y << ' ' << y + 1 << std::endl;

// 4294967295 0
```

В случае знаковых чисел переполнение **запрещено**.

С помощью символа u можно указывать, что это число беззнаковое.

``` cpp
int x = (1u << 31) - 1;
```
 
 Сама по себе единица - это числовая литерала, она имеет тип **int**. Добавляем
 u, получаем беззнаковую единицу, затем беззнаковое число `2^31`, которое не
 помещается в **int**, а `2^31 - 1` уже помещается.

## Представление чисел

Выведем первые 8 бит чисел от 0 до 127.

``` cpp
for (unsigned i = 0; i < 128; ++i) {
    std::cout << i << ' ' << std::bitset<8>(i) << std::endl;
}

// 0 0000000
// 1 0000001
// 2 0000010
// ...
// 126 01111110
// 127 01111111
```

Выведем самое большое беззнаковое число

``` cpp
unsigned huge = 0u - 1;
std::cout << huge << ' ' << (std::bitset<32>(huge)) << std::endl;
std::cout << ~huge << ' ' << std::bitset<32>(~huge) << std::endl;

// 4294967295 11111111111111111111111111111111
// 0 00000000000000000000000000000000
```

Выведем первые 32 бит чисел от -128 до 127.

``` cpp
for (int i = -128; i < 128; ++i) {
    std::cout << i << ' ' << (std::bitset<32>(i)) << std::endl;
}

// -128 11111111111111111111111110000000
// ...
// -4 11111111111111111111111111111100
// -3 11111111111111111111111111111101
// -2 11111111111111111111111111111110
// -1 11111111111111111111111111111111
// 0 00000000000000000000000000000000
// 1 00000000000000000000000000000001
// 2 00000000000000000000000000000010
// 3 00000000000000000000000000000011
// ...
// 127 00000000000000000000000001111111
```

Для всех отрицательных чисел старшая единица является битом знака, для
положительных - ноль является битом знака.

Чтобы получить отрицательное число из положительного, нужно вычесть 1 и
инвертировать все биты.

``` cpp
	int x = 2;
	int negated = ~(x - 1);
	std::cout << x << ' ' << negated << std::endl;
```

Чтобы получить максимальное значение, можно использовать следующую запись.

``` cpp
	int max = std::numeric_limits<int>::max();
	std::cout << max << ' ' << std::bitset<32>(max) << std::endl;
	
	// 2147483647 01111111111111111111111111111111
```

## Числа с плавающей точкой

Несколько видов точности:
- float - обычно 32-bit
- double - обычно 64-bit
- long double - на разных платформах либо 64 бит, либо 80 бит, либо 128 бит

На практике лучше **long double** не использовать.

Схема float:
![Alt text](/img/scheme.png "a title")

Число выглядит так: $sign \cdot 2^{exp} \cdot fraction$. 

# Лекция 4 - Функции & Ссылки

В современном мире люди предпочитают использовать другие типы данных для чисел
из библиотеки <сstdint>.

|                                                           |                                                                                                                                                                                                                                  |
|:---------------------------------------------------------:|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|             int8_t, int16_t, int32_t, int64_t             | целочисленный тип со знаком шириной ровно 8, 16, 32 и 64 бита соответственно без битов заполнения и с использованием дополнения до 2 для отрицательных значений (при условии и только если реализация напрямую поддерживает тип) |
| int_least8_t, int_least16_t, int_least32_t, int_least64_t | наименьший целочисленный тип со знаком шириной не менее 8, 16, 32 и 64 бит соответственно                                                                                                                                        |
|           uint8_t, uint16_t, uint32_t, uint64_t           | целочисленный тип без знака шириной ровно 8, 16, 32 и 64 бита соответственно (при условии и только если реализация напрямую поддерживает этот тип)                                                                               |

Если система не поддерживает какой-то тип, то программа с ним просто не
скомпилируется.

**size_t** - это беззнаковый целочисленный тип результата **sizeof**,
**alignof** и **offsetof**, в зависимости от модели данных.

**size_t** может хранить максимальный размер теоретически возможного объекта
любого типа (включая массив).

**size_t** обычно используется для индексации массивов и в качестве счётчика в
цикле. Программы, использующие другие типы, такие как **unsigned int**, для
индексации массивов, могут не работать, например, на 64-битных системах, если
индекс превышает **UINT_MAX** или если они полагаются на 32-битную модульную
арифметику.

## Функции

Из функции нельзя вернуть несколько значений, но функция может принять несколько
значений.

``` cpp
int add(int a, int b) {
	return a + b;
}
```

Функция **main** бывает без аргументов и с двумя аргументами, которые позволяют
получить доступ к аргументам командной строки.

**int arc** - число аргументов, **const char** argv - указатель на указатель
на константные символы, т. е. массив строчек.

Здесь мы выводим все аргументы командной строки.

``` cpp
int main(int argc, const char** argv) {
    for (int i = 0; i < argc; ++i) {
        std::cout << argv[i] << std::endl;
    }
    return 0;
}
```

Нельзя объявить функцию до того, как она будет использоваться.

``` cpp
int main() {
    std::cout << add(5, 5) << std::endl;
    return 0;
}

int add(int a, int b) {
    return a + b;
}
```

Можно объявить функцию (**forward declaration**) заранее и таким образом
исправить ошибку.

``` cpp
int add(int a, int b);
	
int main() {
    std::cout << add(5, 5) << std::endl;
    return 0;
}

int add(int a, int b) {
    return a + b;
}
```

Так можно записать две функции, которые вызывают друг друга (взаимная рекурсия).

``` cpp
void foo();

void bar() {
    std::cout << __PRETTY_FUNCTION__ << std::endl;
    foo();
}

void foo() {
    std::cout << __PRETTY_FUNCTION__ << std::endl;
    bar();
}

int main() {
    bar();
    return 0;
}
```

При вызове функции создаются копии всех переменных, переданных в функцию, что
дорого по памяти и по производительности. 

``` cpp
#include<iostream>

void greet(std::string name) {
    name = "Bob";
    std::cout << "Hello, " << name << '!' << std::endl;
}

int main() {
    std::string name = "world";
    greet(name);
    std::cout << name << std::endl;
    return 0;
}

// Вывод:
// Hello, Bob!
// world
```

## Ссылки

В C++ есть возможность обращаться к уже существующему в памяти объекту под
другим именем. Чтобы не копировать строчку можно использовать ссылки, добавив
знак &.

``` cpp
#include<iostream>

void greet(std::string& name) {
    name = "Bob";
    std::cout << "Hello, " << name << '!' << std::endl;
}

int main() {
    std::string name = "world";
    greet(name);
    std::cout << name << std::endl;
    return 0;
}

// Вывод:
// Hello, Bob!
// Bob
```

Чтобы переменная, отданная в функцию не была изменена, можно добавить **const**,
константную ссылку на строчку.

``` cpp
#include<iostream>

void greet(const std::string& name) {
    std::cout << "Hello, " << name << '!' << std::endl;
}

int main() {
    std::string name = "world";
    greet(name);
    std::cout << name << std::endl;
    return 0;
}

// Вывод:
// Hello, world!
// world
```

Если мы создали ссылку на какую-нибудь переменную, отвязать её мы уже не сможем.

``` cpp
std::string bob = "bob";
std::string ben = "ben";
std::string& name = bob;
name = ben;  // bob = ben;
```

## Указатели

Другой (более базовый) способ сослаться на что-то уже существующее в памяти -
указатели. Это специальные типы данных, которые могут хранить адрес какой-либо
другой переменной в памяти. Здесь мы можем представлять себе память как длинную
ленту с пронумерованными ячейками (байтами). Сам адрес переменной можно получить
с помощью унарного оператора &:

``` cpp
int main() {
    int x = 42;
    int* ptr = &x;
	
    ++x;
    std::cout << *ptr << "\n";  // 43
    return 0;
}
```

![Alt text](/img/ptr.png "a title")

Формально указатель — это не номер ячейки памяти, а отдельный тип. Но обычно он
может быть преобразован к целому числу. Вот такой код напечатает адреса
переменных в шестнадцатеричном виде:

``` cpp
#include <iostream>

int main() {
    int x = 1, y = 2, z = 3;
    std::cout << &x << "\n";
    std::cout << &y << "\n";
    std::cout << &z << "\n";
}

// Вывод:
// 0x7ffdfee3188c
// 0x7ffdfee31888
// 0x7ffdfee31884
```

Можно заметить, что адреса будут идти «рядом» с шагом **sizeof(int)** по
возрастанию или убыванию — это зависит от платформы и компилятора. Но при
повторном запуске программы они могут отличаться, так как программе может
быть назначен совсем другой сегмент памяти.

Кроме адреса ячейки памяти переменная-указатель обладает ещё и типом данных,
значение которого в этой ячейке лежит. Это позволяет компилятору правильно
интерпретировать обращение к памяти по этому адресу. Поэтому мы используем не
какой-либо абстрактный тип «указатель», а именно «указатель на **int**».

Оператор разыменования (унарная звёздочка) противоположен оператору взятия
адреса (унарному амперсанду). Сравните: &x — это адрес x в памяти, а *ptr -
это значение, живущее по адресу, записанному в ptr.

Указатели, в отличие от ссылок, можно переназначать. Кроме того, есть выделенное
значение никуда не ссылающегося указателя — **nullptr** («нулевой» указатель):

``` cpp
#include <iostream>

int main() {
    int x = 42, y = 13;
    // по умолчанию не инициализируется, тут лежит «случайный» адрес
    int* ptr;
    // «нулевой» указатель
    ptr = nullptr;
    // теперь в ptr лежит адрес переменной x
    ptr = &x;
    std::cout << *ptr << "\n";  // 42
    // можно поменять адрес, записанный в ptr
    ptr = &y;
    std::cout << *ptr << "\n";  // 13
    // можно поменять значение переменной, на которую указывает указатель
    *ptr = 32;
    std::cout << *ptr << "\n";  // 32
    return 0;
}
```

Указатель **nullptr** нельзя разыменовывать: это приведёт к неопределённому
поведению.

Нельзя возращать указатели и ссылки на локальные.
``` cpp
std::string& name() {
    std::string local = "foo";
    return local;
}

int main() {
    std::string ref = name();
    std::cout << ref << std::endl;
}
```

Сложить строки, на которые указывает указатель можно так:
``` cpp
void dup(std::string* ref) {
    (*ref) = (*ref) + (*ref);
}

int main() {
    std::string bob = "bob";
    dup(&bob);
    std::cout << bob << std::endl;
}

// Вывод:
// bobbob
```

## Перегрузки

``` cpp
#include<iostream>
#include<string>

int add(int a, int b) {
    return a + b;
}

std::string add(const std::string& a, const std::string& b) {
    return a + b;
}

int main() {
    int i = 5;
    std::string s = "foo";
	
	add(i, i);
    add("foo", "foo");
}

// Вывод:
// 10
// foofoo
```

Компилятор выбирает подходящую функцию в зависимости от типов аргументов.
Недостаток заключается в том, что код повторяется и эту функцию в идеале
нужно реализовать для всех возможных типов.

# Лекция 5: Массивы

## C-style массивы

``` cpp
void Greet(const std::string& name) {
    std::cout << "Hello, " << name << std::endl;
}

int main() {
    std::string names[3] = {
        "Bob",
        "Ben",
        "Alice"
    };

    for (int i = 0; i < 3; ++i) {
	    Greet(names[i]);
    }

    return 0;
}
```

Если массив не инициализировать или инициализировать только его часть, то
остальные его элементы будут значения по умолчанию (в данном случае пустая
строка)

``` cpp
std::string names[3] = {
    "Bob",
    "Ben",
};
std::string names[3] = {};
```

Если убрать фигурные скобки, то обращение к элементам массива - это **undefined
behavior*.

Размер 10-элементного массива чисел равен 40, т. к. вес каждого **int** в
архитектуре x86-64 равен 4 байтам ($10 \cdot 4 = 40$).

``` cpp
int arr[10] = {};		
std::cout << sizeof(arr) << std::endl; // 40
```

Так можно найти размер массива.
``` cpp
int arr[123123] = {};		
std::cout << std::size(arr) << ' ' << sizeof(arr[0]) / sizeof(arr) << std::endl; 
// 123123 123123
```

Так можно передать массив в функцию. Но это не удобно, т. к. всегда нужно
фиксировать размер массива - 123123.
``` cpp
void Foo(const int (&arr)[123123]) {
    std::cout << arr[34] << std::endl; // 42
    // arr[34] = 43; <- error
}

int main() {
    int arr[123123] = {0};
    arr[34] = 42;
    Foo(arr);
    std::cout << arr[34] << std::endl; // 42
    return 0;
}
```

Второй способ: создать новый тип.

``` cpp
using vector = float[3];

void Foo(const vector& v) {
    std::cout << v[0] << ' ' << v[1] << ' ' << v[2] << std::endl;
}

int main() {
    vector v;
    v[2] = 1.0;
    Foo(v);
    return 0;
}
```

Третий способ. Мы можем передать в функцию массив произвольного размера. Функция принимает указатель на первый элемент массива и размер массива (количество элементов).

``` cpp
void PrintArray(const int* ptr, size_t size) {
    for (size_t i = 0; i < size; ++i) {
        std::cout << *(ptr + i) << ' ';
    }
}

int main() {
    int ints[10];
    PrintArray(&ints[0], std::size(ints));
    return 0;
}
```

С точки зрения указателей любые переменные - это массивы размера 1, поэтому указатели всегда смотрят внутрь массива. ptr + i - сдвинуть указатель на $i \cdot sizeof(ints[0])$ байт (здесь он сдвигается какждый раз на 4 байта).

Четвёртый способ.
``` cpp
void PrintArray(const int* begin, const int* const end) {
    while (begin != end) {
        std::cout << *begin++ << ' ';
    }
}

int main() {
    int ints[10];
    PrintArray(&ints[0], &ints[0] + std::size(ints));
}
```

Сортировка массивов
``` cpp		
int main() {
    int arr[5] = {5, 1, 2, 0, 4};
    std::sort(&arr[0], &arr[0] + std::size(arr));
    PrintArray(&arr[0], &arr[0] + std::size(arr));
    return 0;
}
```

Хочется сказать по поводу этого:
``` cpp	
void PrintArray(const int* begin, const int* const end) {
```
Есть разница
``` cpp	
const int* begin // declare begin as pointer to const int
int* const begin // declare begin as const pointer to int
```
Во втором случае мы можем менять (переприсвоить) значение под указателем, но
не можем менять сам указатель.
``` cpp	
*begin = 123;
begin++; // error
```
В первом наоборот.

Продемонстриуем, как хранится массив в памяти.
``` cpp	
unsigned arr[4] = {
    0x11223344,
    0x55667788,
    0x99aabbcc,
    0xddeeff11,
};
```

Мы объявляем два указателя на начало и конец массива, которые были превращены
в не в указатели на **unsigned int**, не в указатели на **char**. Через
**char** можно читать представление объекта в памяти, а через все остальные типы
нельзя, потому что char имеет размер 1 байт.

**reinterpret_cast** позволяет преобразовывать любой указатель в указатель
любого другого типа. Также позволяет преобразовывать любой целочисленный тип
в любой тип указателя и наоборот. Когда мы хотим указатель превратить в
указатель на char, нужно использовать его.

``` cpp	
const unsigned char* begin = reinterpret_cast<const unsigned char*>(arr);
const unsigned char* end = reinterpret_cast<const unsigned char*>(arr + std::size(arr));
```
Выпишем все байты в этом массиве.
``` cpp	
while (begin != end) {
    std::cout << std::hex << static_cast<unsigned>(*begin);
    ++begin;
}

// 4433221188776655ccbbaa9911ffeedd
```
Массив идёт задом наперёд, потому что процессору так работать проще: первый байт - это самые младшие биты, а последний - самые старшие. Массив идёт плотно, никаких лишних байт.

## Двумерные массивы

Иницилизация
``` cpp
unsigned board[8][8] = {};
```

Двумерный массив - это массив массивов. Поэтому в памяти они хранятся
последовательно: сначала первый массив, затем второй и т. д.

Размер массива нельзя изменить.

Различие между указателем и массивом:

``` cpp
int array[5];

int* pointer = &array[0];
// also allowed to write like this
// int* pointer = array;
// it's the same thing
```

Массив - это список байтов со значениями, а указатель на массив - это адрес
первого элемента массива (точнее он указывает на первый байт первого элемента).

# Лекция 6: Строки и структуры
## Строки

Cтрочки в C++ представлены обычно так:
``` cpp
char str[] = {'H', 'e', 'l', 'l', 'o', '\0'};
```

Есть короткая запись
``` cpp
char str[] = "Hello";
```

``` cpp
void print0(const char* str) {
    while (*str != '\0') {
        std::cout << *str++;
    }
}

int main() {
    char str[] = "Hello";
    // char str[] = {'H', 'e', 'l', 'l', 'o', '\0'};
    char* ptr = &str[0];
    print0(ptr);
}
```

Строчки в языке Паскаль хранятся так:
``` cpp
char str[] = {0, 0, 0, 5, 'H', 'e', 'l', 'l', 'o'};
```
Первые 4 байта резервируем под размер строчки.
  
``` cpp
void print(const char* str) {
    size_t size = 0;

    for (int i = 0; i < 4; ++i) {
        size <<= std::numeric_limits<unsigned char>::digits;
        size |= *str++;
        // 11100101
        // 1110010100000000
        //         11011011
        // 1110010111011011
    }

    while (size > 0) {
        std::cout << *str << std::flush;
        ++str;
        --size;
    }
}

int main() {
    char str[] = {0, 0, 0, 5, 'H', 'e', 'l', 'l', 'o'};
    char* ptr = &str[0];
    print(ptr);
}
```

Этот способ имеет право на жизнь, т. к. если строка очень большая, то предыдущее
представление строчки сильно неэффективно: нужно предварительно узнать длину
строки.

Функция, которая вычисляет длину строчки.
``` cpp
size_t = str_len(str);
```

Функция, которая сравнивает две строки лексикографически.
``` cpp
bool = strcmp(str1, str2);
```
Знак результата - это знак разности между значениями первой пары символов (оба
интерпретируются как **unsigned char**), которые различаются в сравниваемых строках,
т. е.
1. Нулевое значение говорит о том, что обе строки равны.
2. Значение больше нуля указывает на то, что строка **str1** больше строки
**str2**, значение меньше нуля свидетельствует об обратном.

Если сравнить так,
``` cpp
bool = (str1 < str2);
```
то будут сравниваться указатели, а не содержимое строк.

Это массив из строк.
``` cpp
	const char* argv[] = {"foo", "bar"};
```
Чтобы передать его в функцию, мы передаём его размер **argc** и указатель на
указатель на первый элемент строчки.
``` cpp
	int main(int argc, const char** argv) {
	}
```
У **argc** стоит тип **int**, вместо **size_t**, потому что так исторически
сложилось.

## Структуры
Когда мы передаём строчку в функцию, мы предаём два аргумента. Хочется их
соединить в один тип.
``` cpp
void print(const char* str, size_t size) {
}
```

Для этого есть структуры. 
``` cpp
struct CString {
    const char* begin;
    size_t size;
};
```

В отличие от массивов, которые хранят несколько элементов одного типа, структура
может хранить элементы разных типов.

Теперь можно сделать так:
``` cpp
struct CString {
    const char* begin;
    size_t size;
};

void print(const CString& str) {
    for (size_t i = 0; i < str.size; ++i) {
        std::cout << str.begin[i] << std::endl;
    }
}
```

## Как устроены структуры
**CString** в примере выше в x86-64 архитектуре будет иметь размер 16 байт:
**size_t** имеет размер 8 байт, и размер указателя 8 байт. Вообще размер
указателя зависит от разрядности вашего приложения:
- на 32-битной версии - 4 байта
- на 64-битной версии - 8 байт

**Offset** (cмещение) - это целое число, указывающее расстояние (смещение)
между началом объекта и данным элементом в пределах того же объекта.

Рассмотрим пример.    
``` cpp
#include <cstddef>
#include <iostream>

struct StructExample {
	char c;
	double d;
	int i;
};

int main() {
	std::cout
	<< "offset of char             c = " << offsetof(StructExample, c) << '\n'
	<< "offset of double           d = " << offsetof(StructExample, d) << '\n'
	<< "offset of int              i = " << offsetof(StructExample, i) << '\n'
	<< "size of struct StructExample = " << sizeof(StructExample) << '\n';
}

// Possible output:
// offset of char             c = 0
// offset of double           d = 8
// offset of int              i = 16
// size of struct StructExample = 24
```

В x86-64 **char** весит 1 байт, **double** весит 8 байт, **int** весит 4 байт,
поэтому **sizeof** у **StructExample** предположительно равен 1 + 8 + 4 = 13
байт. Но он равен 24 байта.

Почему такое смещение? У каждого типа, кроме **sizeof**, есть ещё свойство под
названием **alignof** (выравнивание) - это степень двойки, которая говорит, по
каким адресам может располагаться тип. Если выравнивание равно 1, то у объектов
этого типа может быть совершенно произвольные адреса. Если выравнивание равно 2,
то у объектов этого типа может быть только адреса кратные 2. Если выравнивание
равно 8, то у объектов этого типа может быть только адреса кратные 8 и т. д.
Зачем так сделано? Так сделано, потому что процессору значительно проще работать
с выравненными объектами типов, повышается производительность. Выравнивание -
это свойство платформы, эти числа нигде не зафиксированы.

``` cpp
std::cout << alignof(char) << std::endl;  // 1
std::cout << alignof(double) << std::endl;  // 8
std::cout << alignof(int) << std::endl;  // 4
```

**StructExample** требует **sizeof(char)** + 7-байтовое заполнение (**padding**) + **sizeof(double)** + **sizeof(int)** = 1 + 7 + 8 + 4 = 20 байт.
Однако размер **sizeof(StructExample)** составляет 24 байта. Это связано с тем,
что наряду с членами структуры переменные типа структуры также будут иметь
естественное выравнивание. Давайте разберемся в этом на примере. Скажем, мы
объявили массив **StructExample**, как показано ниже. 

``` cpp
StructExample struct_array[3];
```

Предположим, что базовый адрес **struct_array** равен 0x0000 для упрощения
вычислений. Если **{StructExample} занимает 20 (0x14) байт, как мы рассчитали,
второй элемент массива **{StructExample} (с индексом 1) будет находиться по
адресу 0x0000 + 0x0014 = 0x0014. Это начальный адрес элемента массива с индексом
1ю Второй член структуры **{StructExample} будет размещен по адресу
0x0014 + 0x1 + 0x7 = 0x001C (десятичное число 28), которое не кратно 8 и
противоречит требованиям выравнивания **double**. Как мы упоминали выше,
требование выравнивания double составляет 8 байт.

Чтобы избежать такого несовпадения, компилятор вводит требования к выравниванию
для каждой структуры. Оно будет как у самого крупного члена структуры. В нашем
случае выравнивание **StructExample** - 8. Если нам нужны вложенные структуры,
размер самой большой внутренней структуры будет соответствовать выравниванию
непосредственно более крупной структуры.

В **StructExample** приведенной выше программы после члена **int** будет
добавлено 4 байта, чтобы размер структуры был кратен ее выравниванию. Таким
образом, размер **StructExample** составляет 24 байта. Это гарантирует
правильное выравнивание даже в массивах.

Как уменьшить отступы (**padding**) структуры? К настоящему моменту может быть
ясно, что дополнение неизбежно. Есть способ минимизировать отступы. Программист
должен объявить члены структуры в порядке возрастания/убывания их размера.
Примером является **StructExample2**, приведенный в нашем коде, размер которого
составляет 16 байт вместо 24 байтов **StructExample**.

``` cpp
struct StructExample2 { 
    double d;
    int i; 
    char c;
};
```

## В каком случае нужно передавать структуру в функцию как ссылку?

Правило такое: если размер структуры не превышает два размера указателя, то
структура передаётся по значению (есть статья "Calling conversions for
different C++ compilers and operating systems" на эту тему).

## Инициализация структуры
1 вариант: сделать пустую структуру, и заполнить её поля.
``` cpp
StructExample2 obj; 
obj.d = 3.14;
obj.i = 4; 
obj.c = 'p';
```
Он не очень удобный и компактный.

2 вариант: в фигурных скобках передать содержимое полей.
``` cpp
StructExample2 obj = {3.14, 4, 'p'};
StructExample2 obj2{3.14, 4, 'p'};
```
Минус: непонятно в каком порядке идут поля в структуре. 

3 вариант: в фигурных скобках пишем имена полей структуры и их инициализаторы. Нельзя менять порядок полей при инициализации. Самый удобный способ.
``` cpp
StructExample2 obj {
    .d = 3.14, 
    .i = 4,
    .c = 'p'
};
```

Если есть указатель на структуру.
``` cpp
StructExample2 ref;
StructExample2* ptr = &ref;
```
Как получить доступ к полям структуры? Например, так:
``` cpp
(*ptr).size = 42;
```
Но это неудобно. Для указателей на структуры есть специальный синтаксис.
``` cpp
ptr->size = 13;
```
Третий способ: распаковка. В квадратных скобках перечисляем имена переменных, которые мы хотим положить значения полей структуры. Если число полей в структуре не равно числу перечисленных переменных компилятор не дал бы сделать распаковку.
``` cpp
const auto& [a, b, c] = ref;
```
Компилятор в a кладёт первое поле, в b - второе, в c - третье.

Это может быть удобно в структуре **Pair**.
``` cpp
struct Pair {
    int a;
    int b;
};

int main() {
    Pair p{1, 2};
    auto [a, b] = p;
}
```

Поля в структуре можно инициализировать значением по умолчанию
``` cpp
struct Rect {
    int width = 0;
    int height = 0;
};
```

\section*{Лекция 7: Классы}

Классы похожи на структуры: это пользовательские типы данных, в которых хранятся
поля. Синтаксически даже ключевые слова **struct** и **class** взаимозаменяемы
(только объявления внутри **struct** по умолчанию публичны, а внутри **class** -
приватны, об этом ниже). Однако мы будем различать семантику структуры и класса:

1. Мы будем использовать **struct** в типах, где не требуется сложная логика по
инициализации и обработке значений. Структуры — это просто набор полей, не
связанных какими-либо ограничениями. Типичный пример — **struct Point**.
``` cpp
struct Point {
    double x = 0.0;
    double y = 0.0;
    double z = 0.0;
};
```
2. Мы будем использовать **class** там, где требуются какие-либо действия при
инициализации и обработке данных. Класс предполагает некоторый инвариант: он
не позволяет изменить данные произвольным образом. Хороший пример — **class
Rect**, который мы рассмотрим ниже. Часы, минуты и секунды не могут быть
3. произвольными числами, и класс должен гарантировать, что они всегда корректны.

``` cpp
struct Rect {
    int width = 1;
    int height = 1;
    int area = 1;
};
```

Такая структура очень проста, но она никак не проверяет корректность времени.
Предполагается, что **width** $\geqslant$ 1 и **height** $\geqslant$ 1. Но
никто не помешает нам присвоить им другие значения:

``` cpp
int main() {
    Rect r;
    r.width = -42;
    r.height = -5;
    r.area = -201;
}
```

Чтобы контролировать значения этих полей и гарантировать их корректность,
объявим класс **Rect**. Три наших поля в классе будут объявлены в
<ins>приватной</ins>, или закрытой области. Это значит, что доступ к ним будут
иметь только особо указанные <ins>дружественные функции</ins> и
<ins>функции из класса</ins> (**member functions**). В style-guide говорится,
что названия приватных полей должны оканчиваться нижним подчёркиванием.
**public**, **private** и **protected** называются
*модификаторами доступа* (про **protected** позже).

Кстати, в других языках программирования функции из класса именуют *методами*,
но в стандарте C++ термина «метод» нет. 

Если не писать **private:** и **public:** в классе, то неявно будет вставлен в
начало **private**. Структура и классы отличаются друг от друга тем, что в
структуре по умолчанию есть доступ к полям **public**, а в классе - к полям
**private**.

``` cpp
class Rect {
    public:
        void SetWidth(int new_width) {
            if (new_width <= 0) {
                // report error
            }
            width_ = new_width;
            UpdateArea();
        }
        
        void SetHeight(int new_height) {
            if (new_height <= 0) {
                // report error
            }
            height_ = new_height;
            UpdateArea();
        }
        
        int Area const {
            return area_;
        }
        
    private:
        void UpdateArea() {
            area_ = width_ * height_;
        }

    private:
        int width_ = 1;
        int height_ = 1;
        int area_ = 1;
};

int main() {
    Rect r;
    r.SeHeight(123);
    r.setWeight(-123);  // error
}
```

Функция **Area** объявлена *константной* - с пометой **const** в конце. Это
значит, что эта функция не может менять состояние объекта (в нашем случае -
не изменяют значения полей **width_**, **height_** и **area_**).

Фактически мы скрыли детали реализации нашего класса и предоставили публичный
интерфейс - набор функций, через которые можно что-то сделать с объектом.

Style-guide: в каждой **private** или **public** секции пишем либо поля класса,
либо методы, не перемешивая их. Сначала пишем все публичные методы, потом все
приватные методы, а потом приватные поля.

Могут быть константные поля: их нельзя менять внутри класса.

## mutable

**mutable** поля - это поля, которые можно менять даже внутри константных методов.
``` cpp
private:
    const int width_ = 1;
    mutable int height_ = 1;
```

Пусть у нас есть огромная база данных прямоугольников.
``` cpp
class RectDataBase {
    public:
        using RectId = uint64_t;
        
        Rect GetRect(RectId) const {
            // ...
        }
        
    private:
        Rect FetchRectFromTheDatabase(RectId id) const;		
};
```
Функция **FetchRectFromTheDatabase** по сети читает базу данных и возвращает
какой-то прямоугольник. Это дорого по времени. И в реальном мире могут быть
часто использованные прямоугольники. Можно воспользоваться кешированием
прямоугольников и хранить, например, первые 10 самых часто использованных.
``` cpp
class RectCache {
    public:
        bool TryGetRect(RectId id, Rect* res) {
            // ...
        }
        
        void PutRect(RectId id, const Rect& rect) {
            // ...
        }
    private:	
};

class RectDataBase {
    public:
        using RectId = uint64_t;
        
        Rect GetRect(RectId id) const {
            Rect result;
            if (cache_.TryGetRect(id, &result)) {  // error without mutable
                return result;
            }
            
            result = FetchRectFromTheDatabase(id);
            cache_.PutRect(result);  // error without mutable
            return result;
        }
        
    private:
        Rect FetchRectFromTheDatabase(RectId id) const;
        
    private:
        mutable RectCache cache_;	
};
```
Здесь мы использовали **mutable** для **cache_**.

## Конструктор

Объявим *конструктор* для начальной инициализации переменных класса **Rect**. 

``` cpp
class Rect {
    public:
        Rect(int width, int height) {
            width_ = width;
            height_ = height;
        }
        
    private:
        int width_ = 1;
        int height_ = 1;
        int area_ = 1;
};

int main() {
    Rect r{123, 456};
    // Or:  Rect r(123, 456);

    return 0;
}
```

Конструктор можно заменить соответствующими методами, но если мы забыли вызвать
один из методов, то какие-то переменные могут быть неинициализированны и
инварианты будут нарушены. А если нет конструктора, то программа просто не
скомпилируется и есть гарантия, что пользователь передаст все необходимые
переменные.

У конструкторов есть ещё один вариант записи.

``` cpp
Rect(int width, int height)
    : width_ = width;
    , height_ = height;
{}
```

Можно делать несколько конструкторов. Они будут работать точно также, как
перегрузки функций.

Если мы создаём объект без значений,
``` cpp
Rect r;
```
то можно вызвать пустой конструктор
``` cpp
Rect() {
    width_ = 0;
    height_ = 0;
}
```
или тот, который делегирует это другому конструктору
``` cpp
Rect()
    : Rect(0, 0)
{}
```

## explixit

Допустим мы хотим сделать квадрат, передав одно число в конструктор.
``` cpp
Rect(int width)
    : Rect(width, width)
{}

...

Rect r(1234);
```

Проблема в том, что можно делать вот так:
``` cpp
void foo(Rect r) {
}

...

int main() {
    Rect r(1234);
    foo(1234);
}
```
Т. е. мы передаём число в функцию и компилятор делает из неё прямоугольник. Это
происходит неявно и если не видеть саму функцию **foo**, то можно не догадаться,
что произойдёт.

Поэтому правило такое: для конструкторов из одного элемента всегда используйте
ключевое слово **explicit**.

``` cpp
explicit Rect(int width)
    : Rect(width, width)
{}

...

Rect r(1234);
```
Теперь мы должны явно указать, что мы создаём прямоугольник.
``` cpp
int main() {
    foo(Rect{1234});
}
```

Также если в функции есть поля по умолчанию, то для данного ниже конструктора
тоже нужно написать **explicit**.
``` cpp
explicit Rect(int width, int height = 0)
    : width_{width}
{}
```

## Деструктор

Деструкторы вызываются в конце жизни объекта. Пишем тильду, дальше имя класса.
Аргументы деструктору передать нельзя.

``` cpp
class Noisy {
    public:
        Noisy() {
            puts(__PRETTY_FUNCTION__);
        }
        
        ~Noisy() {
            puts(__PRETTY_FUNCTION__);
        }
};

int main() {
    Noisy noisy;
    std::cout << "Hello" << std::endl;
} // деструктор вызывается на ЭТОЙ скобке

// Вывод:
// Noisy::Noisy()
// Hello
// Noisy::~Noisy()
```

Деструктор разрушается в конце следующей закрывающейся фигурной скобки.

Тот объект, которые мы создали последним, первым разрушится. Принцип как в стеке.
``` cpp
class Noisy {
    public:
        Noisy(int idx)
            : idx_{idx}
        {
            std::cout << "ctor " << idx_ << std::endl;
        }
        
        ~Noisy() {
            std::cout << "dtor " << idx_ << std::endl;
        }
    
    private:
        int idx_ = 0;
};

int main() {
    Noisy noisy0{0};
    Noisy noisy1{1};
}

// Вывод:
// ctor 0
// ctor 1
// dtor 1
// dtor 0
```

Есть ещё одна тонкость **private**: можно создать функцию, которая снаружи
умеет читать приватные поля. В некоторых случаях это бывает необходимо.

Пишем **friend** в **private** и повторяем сигнатуру функции.

``` cpp
class Rect {
    public:
    void SetWidth(int new_width) {
        if (new_width <= 0) {
            // report error
        }
        width_ = new_width;
        UpdateArea();
    }
    
    void SetHeight(int new_height) {
        if (new_height <= 0) {
            // report error
        }
        height_ = new_height;
        UpdateArea();
    }
    
    int Area const {
        return area_;
    }
    
    friend int RectAreaUnsafe(const Rect& rect); // !!!!!!!!!!!!!!!!!!!
    
    private:
    void UpdateArea() {
        area_ = width_ * height_;
    }
    
    private:
    int width_ = 1;
    int height_ = 1;
    int area_ = 1;
};

friend int RectAreaUnsafe(const Rect& rect);
```


# Лекция 8: Динамическая память

Язык выделяет 3 содержательно разных вида памяти.

1. Статическая память - в ней хранятся глобальные переменных, которые 
объявляются снаружи main. Глобальные переменные создаются до вызова функции
**main**. Они доступны на протяжении всей жизни программы и разрушаются после
вызова функции **main**. Лучше не злоупотреблять глобальными переменными.
2. Автоматическая память - в ней хранятся объекты, которые живут внутри функции.
Память называется автоматической, потому что компилятор за нас уничтожает эти
объекты.	
3. Динамическая память - в ней живут объекты, которые живут столько, сколько
решает программист, а не компилятор.

Создаём **int** в динамической памяти. Если написать так, то память не
освобождается.
``` cpp
for (int i = 0; i < 10000; ++i) {
    int* ptr = new int{123};
}
```
Теперь утечки памяти нет.
``` cpp
for (int i = 0; i < 10000; ++i) {
    int* ptr = new int{123};
    delete ptr;
}
```
Здесь на самом деле мы удаляем адрес на который указывает **int\* ptr**.

Так делать нельзя, потому что запись **int i = ...** означает создание
переменной в автоматической памяти.
``` cpp
int i = new int{123}; // error
```
Писать через равно нельзя, можно только через фигурные или круглые скобки.
``` cpp
// new int = 5; - error
new int{5};
new int(5);
```

Указатель разрушается всегда в конце функции, в которой мы этот указатель
получили, т. к. указатели живут в автоматической памяти.

Утечка памяти не является **underfined behaviour**.

С помощью динамической памяти можно создать большой массив (10 Гбайт).
``` cpp
char* huge = new char[10ull * 1024 * 1024 * 1024];
for (size_t i = 0; i < 1024 * 1024 * 1024; ++i) {
    huge[i] = i % 100;
}
```
Лимит на количество памяти, которое можно выделить, зависит от архитектуры
и операционной системы. Обычно можно выделить до $2^{47}$, на более современных
до $2^{55}$.

В динамической памяти можно создать массив с переменным размером, а в
автоматической нельзя.
``` cpp
size_t size;
std::cin >> size;
volatile char* huge = new char[size];
for (size_t i = 0; i < size; ++i) {
    huge[i] = i % 100;
}
```

Когда помещаем переменную в динамическую память, очень легко забыть **delete**.

Напишем класс умного указателя для **int**. Он называется **UniquePtr**, потому
что это единственный уникальный владелец этого указателя, кто владеет указателем,
тот его и удаляет.
``` cpp
class UniquePtr {
    public:
        UniquePtr(int* ptr)
            : ptr_{ptr}
        {}
        
        int* Get() const {
            return ptr_;
        }
        
        ~UniquePtr() {
            delete ptr_;
        }
        
    private:
        int* ptr_ = nullptr;
        // delete nullptr - correct code	
};
```
Тогда код будет выглядеть так (не надо писать **delete**):
``` cpp
int* allocate() {
    int* ptr = new int{123};
    return ptr;
}

int main() {
    UniquePtr ptr0 = allocate();
    UniquePtr ptr = new int{123};
    return 0;
}
```
C одной стороны, мы можем хранить большие массивы, но, с другой стороны,
переменная будет жить до следующей фигурной скобки (т. е. некоторые свойства
динамической памяти теряются).

**std::unique_ptr** ведёт себя точно также.
``` cpp
std::unique_ptr<int> ptr0{allocate()};
```

Если возращать **unique_ptr** из функции, то он не будет удаляться.
``` cpp
std::unique_ptr<int> AllocateSmart() {
    std::unique_ptr<int> ptr_allocate{new int{123}};
    return ptr_allocate;
}

// Implicitly, the following is happening
// ptr_allocate = new int{123};
// ptr_main = ptr_allocate;
// ptr_allocate = nullptr;
// delete ptr_allocate;

int main() {
    std::unique_ptr<int> ptr_main = AllocateSmart(;
}
```

**std::shared_ptr** - это интеллектуальный указатель, который сохраняет
совместное владение объектом посредством указателя. Несколько **shared_ptr**
объектов могут владеть одним и тем же объектом. Объект уничтожается, а его
память освобождается, когда происходит одно из следующих событий:

1. последний оставшийся **shared_ptr** владелец объекта уничтожается;
2. последнему оставшемуся **shared_ptr** владельцу объекта присваивается 
другой указатель через **operator=** или **reset()**.


``` cpp
std::shared_ptr<int> s1{new int{42}};
std::shared_ptr<int> s2 = s1;
std::shared_ptr<int> s3 = s2;
```

Если мы пишем **{new} с квадратными скобками, то удалять переменную тоже нужно
с квадратными скобками.
``` cpp
int* array = new int[10];
delete[] array;

int* one_int = new int{42};
delete one_int;
```

# Лекция 9: Контейнеры

Мы знаем массивы двух видов:
``` cpp
// статический массив
int array[10];

// динамический массив
int* array2 = new int[10];
delete[] array2;
```

Можно создать массив в статической памяти,

Удобная обёртка над динамическим массивом.
``` cpp
std::vector<int> vec;
```

``` cpp
vec1.push_back(123);
vec1.push_back(42);
vec1.push_back(19);
std::cout << vec1.size() << std::endl; // 3
```

``` cpp
vec1.resize(123);
vec1[123] = 42;
```

``` cpp
class VectorInt {
public:
    VectorInt() {
    }
    
    ~VectorInt() {
    delete[] begin_;
    }
    
    size_t size() const {
        return size_;
    }
    
    size_t capacity() const {
         return capacity_;
    }
    
    int operator[](size_t idx) const {
        return begin_[idx];
    }
    
    int& operator[](size_t idx) {
        return begin_[idx];
    }
    
    // Схема работы метода push_back
    // [1][2][3][4][5][x][x][x]
    // ^^^^^^^^^^^^^^^^^
    // size = 5
    // capacity = 8
    //
    // [1][2][3][4][5][6][x][x]
    // ^^^^^^^^^^^^^^^^^^^^
    // size = 6
    // capacity = 8
    //
    // [1][2][3][4][5][6][7][x]
    // ^^^^^^^^^^^^^^^^^^^^
    // size = 7
    // capacity = 8
    //
    // [1][2][3][4][5][6][7][8]
    // ^^^^^^^^^^^^^^^^^^^^^^^
    // size = 8
    // capacity = 8
    //
    // [1][2][3][4][5][6][7][8]
    //  v  v  v  v  v  v  v  v    copy
    // [1][2][3][4][5][6][7][8][9][x][x][x][x][x][x][x]
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^
    // size = 8
    // capacity = 16
    
    void push_back(int value) {
        if (size_ == capasity_) {
            grow();
        }
        begin_[size_] = value;
        size_++;
    }
    
    void pop_back();
    
    int* begin();
    int* end();
    const int* begin() const;
    const int* end() const;

private:
    void grow() {
        size_t new_capasity = std::max(capasity_ * 2, size_t{1}); // что это?
        
        int* new_begin = new int[new_capasity];
        for (size_t i = 0; i < size_; ++i) {
            new_begin[i] = begin_[i];
        }
        
        delete[] begin_;
        begin_ = new_begin;
        capacity_ = new_capacity;
    }
    
private:
    int* begin_ = nullptr;
    size_t size_ = 0;
    size_t capacity = 0;
};

int main() {
    VectorInt v;
    
    for (int i = 0; i < 129; ++i) {
        v.push_back(i);
        std::cout << v.size() << ' ' << v.capacity() << std::endl;
    }
    
    // Вывод:
    // 1 1
    // 2 2
    // 3 4
    // 4 4
    // 5 8
    // 6 8
    // 7 8
    // 9 16
    // ...
}
```

``` cpp
class Noisy {
public:
    Noisy() {
        puts(__PRETTY_FUNCTION__);
    }
    
    ~Noisy() {
        puts(__PRETTY_FUNCTION__);
    }
};

Noisy* do_new(size_t count) {
    Noisy* ptr = (Noisy*)malloc(sizeof(count) + sizeof(Noisy) * count);
    if (ptr == nullptr) {
        throw std::bad_alloc{};
    }
    
    for (size_t i = 0; i < count; ++i) {
        // способ позвать конструктор на сырой памяти
        new (ptr + i) Noisy{};
    }
    
    return ptr;
}

void do_delete(Noisy* n) {
    size_t count = ...;

    for (size_t i = 0; i < count; ++i) {
        n[i].~Noisy();
    }
    free(n);
}

int main() {
    Noisy* p = do_new(10);
    do_delete(p);
    return 0;
}
```

``` cpp
void VectorInt::pop_back() {
    std::destroy_at(begin_ + size_ - 1);
    size_--;
}
```

Пройтись по вектору можно так:
``` cpp
// Range-based for
for (auto value : v) {
    std::cout << value << std::endl;
}
```

Для этого нужно определить итератор для нашего вектора. Теперь итерация по
вектору через for работает.
``` cpp
int* begin() {
    return begin_;
}

int* end() {
    return begin_ + size_;
}

const int* begin() const {
    return begin_;
}

const int* end() const {
    return begin_ + size_;
}
```

``` cpp
{
    auto begin = v.begin();
    auto end = v.end();
    while (begin != end) {
        auto value = *begin;
        ++begin;
        
        std::cout << value << std::endl;
    }
}
```

Можно менять объекты в range-based for
``` cpp
for (int& value : v) {
    value = 123;
}
for (const int& value : v) {
    std::cout << value << std::endl;
}
// Вывод:
// 123
// 123
// 123
// ...
```

``` cpp
include <algorithm>

int main() {
    vector<int> v;
    std::sort(v.begin(), v.end());
    std::sort(v.begin(), (v.begin() + v.end()) / 2);
    std::reverse(v.begin(), v.end());
    return 0;
}
```

Обёртка над статическим массивом.
``` cpp
std::array<int, 10> arr;
```

Список
``` cpp
std::list<int> l;
```

``` cpp
struct Node {
    int value;
    Node* prev = nullptr;
    Node* next = nullptr;
};

class NodeIterator {
public:
    NodeIterator(Node* node)
        : node_{node}
    {}

    NodeIterator& operator++() {
        node_ = node_->next;
        return *this;
    }
    
    NodeIterator operator++(int) {
        NodeIterator copy = *this;
        node_ = node_->next;
        return copy;
    }
    
    int operator*() const {
        return node_->value;
    }
    
    int& operator*() const {
        return node_->value;
    }
    
    bool operator==(const NodeIterator& other) {
        return node_ == other.node_;
    }
    
    bool operator!=(const NodeIterator& other) {
        return !(*this == other);
    }

private:
    Node* node_ = nullptr;
};

class List {
public:
    List() {
        fake_ = new Node{0, nullptr, nullptr};
        fake_->next = fake_;
        fake_->prev = fake_;
    }
    
    void push_back(int value) {
        Node* next = new Node{value, nullptr, nullptr};
        next->prev = fake_->prev;
        next->next = fake_;
        node->prev->next = node;
        node->next->prev = node;
    }
    
    void erase(Node* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
        delete node;
    }
    
    Node* at(size_t i) {
        Node* ptr = fake_;
        do {
            ptr = ptr->next;
        } while (i -> 0);
        return ptr;
    }
    
    NodeIterator begin() {
        return NodeIterator{fake_->next};
    }
    
    NodeIterator end() {
        return NodeIterator{fake_};
    }
    
private:
    Node* fake_;
};

int main() {
    List li;
    li.push_back(123);
    li.push_back(42);
    li.push_back(13);
    for (auto value : li) {
        std::cout << value << std::endl;
    }
    return 0;
    
    // Вывод:
    // 123
    // 42
    // 13
}
```

# Последовательные контейнеры

## std::string

``` cpp
std::string s;
std::vector<char> v;

string.size();
string.capacity();
string.begin();
string.end();
string.push_back('a');
string.pop_back();
```

``` cpp
char str[] = "Hello";
```

``` cpp
const char* ptr = str;
```

``` cpp
strlen(ptr);
```

``` cpp
std::string string{"Hello"};
std::cout << "string.size() = " << string.size() << std::endl;
for (size_t i = 0; i < 6; ++i) {
    std::cout << static_cast<int>(string[i]) << std::endl;
}
// Вывод:
// string.size() = 5
// 72
// 101
// 108
// 108
// 111
// 0 - всегда выводится ноль, не underfined behaviour
```

``` cpp
std::string string{"Hello"};
std::vector<char> strvec{'H', 'e', 'l', 'l', 'o', '\n'};
std::cout << (void*)& string << ' ' << (void*)string.c_str() << std::endl;
std::cout << (void*)& strvec << ' ' << (void*)strvec.data() << std::endl;

// Вывод:
// 0x16db1e5c0 0x16db1e5c0
// 0x16db1e600 0x6020000000b0
```

## std::string_view

``` cpp
std::string_view sv{string};
```

substr копирует данные 
``` cpp
void foo(const std::string& s) {
    auto substr = s.substr(5, 10); // error
}
```

Исправление

``` cpp
void foo(const std::string& s) {
    auto begin = s.begin() + 5;
    auto end = begin + 10;
    
    while (begin != end) {
        std::cout << *begin++;
    }
}

int main() {
    std::string string{"a very long striiiiiing"};
    foo(string);
    return 0;
}

// Вывод:
// y long str
```

В каких-то случаях компилятор может неявно сделать это:
``` cpp
foo("a very very very long string");
// std::string tmp{"a very very very long string"};
// foo(tmp);
```

``` cpp
std::string_view sv = std::string{"hehe"}; // underfined behaviour
```

``` cpp
void foo(std::string_view sv) {
    auto substr = s.substr(5, 10);
}
```

``` cpp
class StringView {
public:
    StringView(const char* begin, const char* end)
        : begin_{begin}
        , end_{end}
    {}
    
    StringView(const std::string& s)
        : begin_{s.data()}
        , end_{s.data() + s.size()}
    {}
    
    StringView substr(size_t pos, size_t length) {
        return StringView{begin_ + pos, begin_ + pos + length};
    }

private:
    const char* begin_;
    const char* end_;
};
```

``` cpp
std::string_view str = "Hello";
std::string_view sv = str;
std::cout << sv << std::endl;
str.push_back('a');
str.push_back('a');
str.push_back('a');
str.push_back('a');
str.push_back('a');
str.push_back('a');
str.push_back('a');
// ...
str.push_back('a');
str.push_back('a');
std::cout << sv << std::endl;

// Вывод:
// Hello
// 
```
Строка переехала в динамическую память. std::string_view всё ещё указывает на старое место.

В этом коде sanitizer поймает проблему.
``` cpp
std::string str = "Helloaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
std::string_view sv = str;
std::cout << sv << std::endl;
for (int i = 0; i < 1024; ++i) {
    str.push_back('a');
}
std::cout << sv << std::endl;
```

Так делать нельзя
``` cpp
class Foo {
public:
    void foo(std::string_view s) {
        copy = s;
    }

private:
    std::string_veiw copy;
};
```

``` cpp
std::string str = "Hello";
std::string_view sv = str;
std::cout << sv << std::endl;
for (int i = 0; i < 24; ++i) {
    std::cout << str.size() << ' ' << sv << std::endl;
    str.push_back('a');
}

// Вывод:
// Hello
// 5 Hello
// 6 Hello
// 7 Hello
// 8 Hello
// ...
// 21 Hello
// 22 Hello
// 23 P@
// 24 P@
// 25 P@
// ...
```

## std::deque

``` cpp
std::deque<int> d;
d.push_back(1);
d.push_back(2);
d.push_back(3);
d.push_front(1);
d.push_front(2);
d.push_front(3);
```

``` cpp
// [255] <-> [256] <-> [256] <-> [256] <-> [256] <-> [254]
// [255] <-> [256] <-> [256] <-> [256] <-> [256] <-> [255]
// [255] <-> [256] <-> [256] <-> [256] <-> [256] <-> [256]
// [255] <-> [256] <-> [256] <-> [256] <-> [256] <-> [256] <-> [1]
// [256] <-> [256] <-> [256] <-> [256] <-> [256] <-> [256] <-> [1]
// [1] <-> [256] <-> [256] <-> [256] <-> [256] <-> [256] <-> [256] <-> [1]

// block_index(i) = (i - first_block.size()) // 256
// block_position(i) = (i - first_block.size()) % 256
```

``` cpp
std::vector<int> v;
v.push_back(1);
int& first = v[0];
v.resize(1000);
std::cout << first << std::endl;
```

Пока не сделаете pop_back ссылка будет валидной.
``` cpp
int& ref = d[448];
```

## std::queue

``` cpp
std::queue<int> qu;
// queue<int, std::deque<int>>
qu.back();
qu.emplace();
qu.empty();
qu.front();
qu.pop();
qu.pop();
qu.push();
qu.size();
```

## std::stack

``` cpp
std::stack<int> qu;
// stack<int, std::deque<int>>
```

## std::priority_queue

Очередь с приоритетами
``` cpp
std::priority_queue<int> pq;
qu.pop();
qu.emplace();
qu.empty();
qu.push();
qu.size();
qu.top();
```

``` cpp
std::priority_queue<int, std::vector<int>, std::less<int>> pq;
// Кастомный компаратор (теперь куча на максимум).
std::priority_queue<int, std::vector<int>, std::greater<int>> pq;
```

Можно написать свой компаратор
``` cpp
struct MySuperComparator {
    bool operator()(int lhs, int rhs) const {
        return lhs < rhs;
    }
};

int main() {
    std::priority_queue<int, std::vector<int>, MySuperComparator> pq;
    return 0;
}
```

``` cpp
void foo(std::string_view s) {
    auto substr = s.substr(5, 10);
}
```

# Операторы. Rule of three

Правило трёх — правило в C++, гласящее, что если класс или структура определяет
один из следующих методов, то они должны явным образом определить все три метода:

- Деструктор
- Конструктор копирования
- Оператор присваивания копированием

Эти три метода являются особыми членами-функциями, автоматически создаваемыми
компилятором в случае отсутствия их явного объявления программистом. Если один
из них должен быть определен программистом, то это означает, что версия,
сгенерированная компилятором, не удовлетворяет потребностям класса в одном
случае и, вероятно, не удовлетворит в остальных случаях. 

``` cpp
class String {
public:
    // Конструктор класса
    String(const char* str) {
        size_t length = std::strlen(str) + 1;
        
        begin_ = new char[length];
        memcpy(begin_, str, length);
        end_ = begin + length;
        end_cap_ = end_;
    }

    // Конструктор копирования
    String(const String& other) {
        // Вызываем оператор присваивания
        *this = other;
    }
    
    // Оператор присваивания копированием
    
    // Не сработает, потому что компилятор скопирует все поля
    // String& operator=(const String&) = default

    String& operator=(const String&) {
        // Устраняем утечку памяти
        Reset();
    
        size_t allocated = other.end_cap_ - other.begin_;
        size_t used = other.end_ - other.begin_;
        // Выделяем массив размера allocated и инициалищзируем нулями (пустые фигурные скобки)
        begin_ = new char[allocated]{};
        // копируем байты
        memcpy(begin_, other.begin_, used);
        end_cap_ = begin_ + allocated;
        end_ = begin_ + (other.end_ - other.begin_);
        return *this;
        // возращаем *this, чтобы мождно делать так
        // s2 = s = s = s;
    }
    
    // Деструктор
    ~String() {
        Reset();
    }
    
    void Reset() {
        delete[] begin_;
        begin_ = nullptr;
        end_ = nullptr;
        end_cap_ = nullptr;
    }
    
    const char* Ptr() const {
        return begin_;
    }

private:
    const char* begin_ = nullptr;
    // Отвечает за заполненную память
    const char* end_ = nullptr;
    // Отвечает за выделенную память
    const char* end_cap_ = nullptr;
};

int main() {
    std::string s1{"foo"};
    std::string s2{s1};
    
    s2 = s1;
    
    std::cout << s1.Ptr() << ' ' << s2.Ptr() << std::endl;
    // Вывод:
    // foo foo
}
```

``` cpp
class Iterator {
public:
    // Префиксный оператор инкремента
    Iterator& operator++() {
        ptr_++;
        return *this;
    }
    
    // Постфиксный оператор инкремента
    Iterator operator++(int) {
        Iterator copy = *this;
        ptr_++;
        return copy;
    }
    
    const char& operator*() {
        return *ptr_;
    }
    
private:
    const char* ptr_ = nullptr;
};
```

``` cpp
class UniquePtr {
public:
    UnquePtr(int* ptr)
        : ptr_{ptr}
    {}
    
    ~UniquePtr() {
        delete ptr_;
    }

private:
    int* ptr_;
}

int main() {
    
}
```
